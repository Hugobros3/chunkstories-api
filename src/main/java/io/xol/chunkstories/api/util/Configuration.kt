//
// This file is a part of the Chunk Stories API codebase
// Check out README.md for more information
// Website: http://chunkstories.xyz
//

package io.xol.chunkstories.api.util

import io.xol.chunkstories.api.GameContext
import io.xol.chunkstories.api.events.config.OptionSetEvent
import io.xol.chunkstories.api.input.Input
import io.xol.chunkstories.api.input.KeyboardKeyInput
import io.xol.chunkstories.api.math.Math2
import java.io.File
import java.io.FileReader
import java.io.FileWriter
import java.nio.charset.Charset
import java.util.*

/** Chunk Stories offer a relatively fancy way of managing user-configurable options, by way of the
 * **Configurations** API. This API allows you to declare *Configurations*, that hold a bunch of *Options*
 * that can be modified accorded to the option's value type and range. */
class Configuration(optionsSet: Set<Option<*>>, val context: GameContext?) {

    val optionsMap = mutableMapOf<String, Option<*>>()
    val options: Set<Option<*>>
        get() = optionsMap.values.toSet()

    init {
        for(option in optionsSet)
            optionsMap[option.name] = option
    }

    open inner class Option<T>(val name: String, val defaultValue: T) {
        var value: T = defaultValue

        val hooks = mutableListOf<() -> Unit>()

        /** Try setting the value of that option to the argument. Will fire an
         * EventOptionSet, returns true when successful */
        open fun trySetting(value: T): Boolean {
            val event = OptionSetEvent(this)
            context?.pluginManager?.fireEvent(event)
            if (!event.isCancelled) {
                this.value = value
                hooks.forEach { it.invoke() }
                return true
            }

            return false
        }

        fun trySettingRaw(value: Any) {
            val casted = value as? T ?: return
            trySetting(casted)
        }
    }

    /** Created when the 'type' property resolves to 'toggle' or 'bool' or
     * 'boolean'  */
    inner class OptionBoolean(name: String, defaultValue: Boolean) : Option<Boolean>(name, defaultValue) {
        fun toggqle() = trySetting(!value)
    }

    /** Created when the 'type' property resolves to 'int'  */
    inner class OptionInt(name: String, defaultValue: Int) : Option<Int>(name, defaultValue)

    /** Created when the 'type' property resolves to 'double'  */
    open inner class OptionDouble(name: String, defaultValue: Double) : Option<Double>(name, defaultValue)

    /** Created when the 'type' property resolves to 'scale'  */
    inner class OptionDoubleRange(name: String, defaultValue: Double, val minimumValue: Double, val maximumValue: Double, val granularity: Double) : OptionDouble(name, defaultValue) {
        override fun trySetting(value: Double) : Boolean {
            val clampedValue = Math2.clampd(value, minimumValue, maximumValue)
            val actuallySettingThisValue = if(granularity != 0.0) {
                val inverted = 1.0 / granularity
                val rounded = Math.round(clampedValue * inverted).toDouble()
                rounded * inverted
            } else clampedValue

            return super.trySetting(actuallySettingThisValue)
        }
    }

    /** Created when the 'type' property resolves to 'choice'  */
    inner class OptionMultiChoice(name: String, defaultValue: String, val possibleChoices: List<String>) : Option<String>(name, defaultValue) {
        override fun trySetting(value: String): Boolean {
            if(!possibleChoices.contains(value))
                return false
            return super.trySetting(value)
        }
    }

    /** Created when an input is *not* declared using the 'hidden' flag in a .inputs
     * file! */
    inner class OptionInput(name: String, defaultValue: Input) : Option<Input>(name, defaultValue)

    /** Looks for a certain option. */
    operator fun <T : Option<*>> get(optionName: String): T? {
        val option = optionsMap.get(optionName)
        return if(option != null) option as T else null
    }

    fun registerOption(option: Option<*>) = optionsMap.put(option.name, option)

    operator fun plusAssign(option: Option<*>) { registerOption(option) }

    fun save(file: File) {
        val properties = Properties()
        optionsMap.values.forEach { properties[it.name] = it.value }
        properties.store(FileWriter(file), "File autogenerated on ${Date()}")
    }

    fun load(file: File) {
        val properties = Properties()
        properties.load(FileReader(file))
        properties.forEach { (k,v) -> optionsMap.get(k)?.trySettingRaw(v) }
    }
}
